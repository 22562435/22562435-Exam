---
output:
  md_document:
    variant: markdown_github
---

# Purpose

The purpose of this file is to discuss and give a walk through my thinking when tackling the Data Science exam, and to explain the functions created so that I have a reference point to go back against when reviewing the functions in the future. 


Setup includes all functions used in the exam. 
```{r setup}

rm(list = ls()) # Clean your environment:
gc() # garbage collection - It can be useful to call gc after a large object has been removed, as this may prompt R to return memory to the operating system.
library(tidyverse)
list.files('code/', full.names = T, recursive = T) %>% .[grepl('.R', .)] %>% as.list() %>% walk(~source(.))
```
#Question 1

Question 1 dealt with baby name popularity and how correlated baby names today are with baby names of tomorrow. Additionally the question investigated the route causes of baby name innovation, notably pop culture.

The first function called was import_multiple_rds(). This is a function that takes in a pathway, and looks at the folder inside that pathway and imports all rds files into the global environment. It is initialised to path = "data/."
```{r}
import_multiple_rds("data/US_Baby_names")
```

The second sets of functions deal with data wrangling. get_name_rank_per_gender_n_year() is a function ranks names by year and gender based on their total counts and tracks their ranks three years later. It groups and summarizes the data, assigns ranks, and then merges the data to include future ranks, arranging the final output by year, gender, and current rank.

add_growth_of_name_variable() is a function that calculates the growth rate of name popularity over time within a given dataset. It takes in a database and then sorts the data by name, gender, and year, then computes the growth rate based on the current and previous counts for each name and gender. The resulting dataset includes this new growth rate variable and is arranged by year, gender, and current rank. 

```{r}
rankednames <- Baby_Names_By_US_State %>% 
    get_name_rank_per_gender_n_year() %>% 
    add_growth_of_name_variable() 
```

The question called for a plotting of the Spearman rank-correlation. plot_spearman_graph() is a function that creates a Spearman rank correlation plot over time, separated by gender, based on the top 25 baby names each year. The function begins by filtering the data for males and females, calculates the Spearman rank correlation for each year, combines the results, and plots the correlations over time with a vertical line marking the year 1990, which is a year significant to the question. The resulting plot is returned. Its input "x" is the data frame. 
```{r}
rankednames %>%    plot_spearman_graph()
```


The get_top_n_growth_names function takes three inputs: the database, the amount of unique names it wants returned, and criteria for selection. It filters and processes a dataset to identify the top N names with the highest growth rates within a specified top ranking. It first filters the data to include only entries with a rank less than or equal to the provided TOP rank value. This is to account for the fact that growth rates are higher for uncommon names, as its easier to go from 2 to 4, than 200 to 400. 
The function then selects the top N names with the highest growth rates, ensuring each name is unique. Finally, it returns a data frame containing entries for these top N names.

This is passed onto the function fill_missing_years() which takes a dataset of names with their counts over various years and fills in any missing years with zero counts. This ensures that for each name and gender combination, the dataset includes entries for all years from the earliest year in the dataset to the latest year in the dataset, with zero counts for years where data is missing.
To do this, the function groups the data by Name and Gender, and then for each group, it adds rows for missing years before the first recorded year and after the last recorded year, setting Total_Count_current to zero for these added years. Finally, it combines these rows with the original data and returns the completed dataset.

Eventually this is passed onto plot_ridge_names(), which takes in the data and returns a ridge plot over the years for each names popularity. 

```{r ridge plot}

rankednames %>%
    get_top_n_growth_names(15,TOP = 120) %>% 
    fill_missing_years() %>% 
    plot_ridge_names()
    

```


Find_top_names() is given a list of names it should search for in a data base of music charts. It is also given a data base to help complete its search. The function identifies and retrieves top-ranked songs or artists from the charts dataset that match names with the highest growth rates in the rankednames dataset. For each name provided in, it first determines the year prior to the year with the highest growth rate. It then searches through charts to find instances where the name appears in either the song or artist columns for that specific year. If matches are found, it selects the top-ranked entry based on peak Billboard 100 rank, therefore ensuring the most popular song. 
The function continues this process for each name it is given, appending the results into a final table which includes the name, song or artist, and corresponding details like peak-rank. 



#Question 2

Again my data is called in using the function import_multiple_rds() 

```{r question 2 setup}
import_multiple_rds("data/Coldplay_vs_Metallica")
```

The rest of the data is called in and merged together using the function import_multiple_csv_and_join(). This function automates the process of importing multiple CSV files from a specified directory and merges them into a single data frame. It begins by fetching the names of all CSV files in the directory that match the pattern .csv. Each CSV file is then read into a list using lapply and read.csv. The function proceeds to merge all data frames in data_list iteratively using full_join, ensuring that columns with common names across data frames are used as keys for merging. Finally, it returns the merged data frame containing combined data from all CSV files.

```{r data wrangling and filtering,include=FALSE}
data<-import_multiple_csv_and_join("data/Coldplay_vs_Metallica") %>% 
    merge_na_coloumns("duration","duration_ms") %>% 
    merge_na_coloumns("album_name","album") %>% 
    remove_rows_containing("name",c("live","Live","demo","Demo")) %>% 
    remove_rows_containing("album_name",c("live","Live","Deluxe","deluxe","Remastered","Edition")) 

```

However not all variables had overlapping variable names, therefore I created a function called merge_na_coloumns() that merged the two column variables where NA's were present in rows. Additionally the function deleted the duplicate column.

The music analysis required that certain albums or songs were filtered out. This pertained to live albums or demo songs. Naturally I created a function that removed the rows that contained mention fo these trigger words. The function worked by providing a data frame, a column to look at, and a list of trigger words. Using grepl the function checks each value in the specified column against the pattern, filtering out rows that match. If an error occurs during the process, it outputs a message detailing the error. Finally, the function returns the modified data frame with rows containing the trigger words removed.

This data frame is now passed onto the function violin_graph_music().
```{r violin graph,fig.cap="Song Popularity by Album for Coldplay and Metallica\\label{coldplaymet}"}
data %>% violin_graph_music()

```


This function creates a violin plot using ggplot2 to visualize song popularity across albums in a given data frame. It groups the data by album_name, filters out albums with less than two entries, and then plots the distribution of popularity scores. The plot also includes jittered points to show the distribution of tempo values within each album. The colour and fill aesthetics are mapped to artist. 


plot_time_trend_of_similar_artist() is the ploting function of question 2.
```{r timetrend coldplay tempo , fig.cap="Time trend of tempo for Coldplay and similar artists "}
Broader_Spotify_Info %>%  plot_time_trend_of_similar_artist("Coldplay","tempo")

```

It takes on three inputs, a database, an artists name, and a Spotify attribute. It then graphs all points of that attribute through time for that artist and for artists similar to that artist.  It then plots a regression line for the spotify attribute through time for that artist and for similar artists. More importantly, for the plot_time_trend_of_similar_artist() to get information regarding similar artists, it calls on the function filter_artists_and_tags() within plot_time_trend_of_similar_artist().

The filter_artist_and_tags() function processes the given music database to analyse a specific artist's data. It filters the database for the given artist_name, determines the artist's active years, and identifies the top three most frequent tags from their tracks. It then filters the entire database for entries with these tags within the artist's active years. A new column, 'Artist,' differentiates between the specified artist's tracks and those of similar artists. 




# Question 3

```{r}
data<-import_multiple_csv_and_join("data/Ukraine_Aid/.") %>%
  rename(TotalBilateralAllocations = `Total.bilateral.allocations...billion.`) %>% 
  rename(TotalBilateralCommitments = `Total.bilateral.commitments...billion.`)   
map_data <- ne_countries(scale = "medium", returnclass = "sf") %>%
  left_join(data, by = c("name" = "Country"))
```

















```{r Question 3}


```

```{r Question 4}


```




